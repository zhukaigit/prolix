# 数据结构及算法学习笔记

## 栈

1. 特点

   先进后出，后进先出

2. 为什么需要栈

   栈是一种操作受限的数据结构，其操作特性用数据和链表都可以实现。但任何数据结构都是对特定场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免引发错误操作的风险。所以当某个数据集合只涉及在某端插入和删除数据，且满足先进后出，后进先出的操作特性是，用栈来实现是最佳的。

3. 实现

   基于链表的实现叫**顺序栈**，基于数组的实现叫**链式栈**

4. 应用

   1. 在函数调用中的应用

   2. 在表达式求值中的应用

      如求出34+13*9+44-12/3的值

   3. 在括号匹配中的应用



## 队列

1. 特点

   先进先出

2. 基本操作

   入队：往队列尾部放入一个元素

   出队：从队列头部取出一个元素

3. 实现

   1. 基于链表实现的叫**链式队列**

   2. 基于数组实现的叫**顺序队列**

      **循环队列**也是通过数组实现的，可以避免数据的搬移

4. 应用

   对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。比如：线程池、数据库连接池等



## 递归

1. 递归需要满足的三个条件

   1. 一个问题的解可以分解为几个子问题的解
   2. 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样
   3. 存在递归终止条件

2. 递归代码警惕堆栈溢出

   系统栈或虚拟机栈内存空间一般不大。如果递归求解的数据规模过大，递归层次很深，一直压入栈，就会有堆栈溢出风险

   解决方式：可用在代码中控制较小的递归深度，比如10，50层。如果太大，这种方式并不是很实用

3. 递归代码警惕重复计算

   解决方式：可用通过哈希表储存函数计算结果，每次计算之前都从哈希表中获取，没有再计算。如下示例：

   ```java
   public int f(int n) {
     if (n == 1) return 1;
     if (n == 2) return 2;
     
     // 先从hashMap从获取，只有不存在的时候再去计算，这样可避免重复计算问题
     if (hashMap.containsKey(n)) {
       return hashMap.get(n);
     }
     
     int ret = f(n-1) + f(n-2);
     hashMap.put(n, ret);
     return ret;
   }
   ```

   

4. 怎么将递归代码改写为非递归代码

   ```java
   int f(int n) {
     if (n == 1) return 1;
     if (n == 2) return 2;
     return f(n-1) + f(n-2);
   }
   
   //改为如下
   
   //这种方式即不会存在一直压入栈的问题，从而导致的栈内存溢出。
   int f(int n) {
     if (n == 1) return 1;
     if (n == 2) return 2;
     
     int ret = 0;
     int pre = 2;
     int prepre = 1;
     for (int i = 3; i <= n; ++i) {
       ret = pre + prepre;
       prepre = pre;
       pre = ret;
     }
     return ret;
   }
   ```



## 排序

1. 如何分析一个算法

   1. 算法的执行效率

      1. 时间复杂度分析

         包括最好、最坏、平均时间复杂度

      2. 时间复杂度的系数、低阶、常量

         时间复杂度反应的是数据规模n很大时增长的一个趋势，所以它表示的时候会忽略系数、低阶、常量。但我们待排序数据规模不大时，需要考虑进去

      3. 比较次数与交换（或移动）次数

   2. 算法的内存消耗

      可以用空间复杂度反应。对于**原地排序**，其空间复杂度为O(1)。

   3. 算法的稳定性

      稳定性排序：如果待排序的元素中存在两个相等的元素，经过排序之后，两个元素之间原有的先后顺序保持不变。

2. 有序度

   若`i < j 且 arr[i] < arr[j]`，即有序的。

   **逆有序度 = 满有序度 - 有序度**

   **满有序度 = n*(n-1)/2**

   排序中的每一次**交换**就是减少逆序度，增加有序度的过程。当你逆序度为0，达到满有序度时，排序结束。

3. **冒泡排序**

   1. 实现：每一轮都从下标为0的位置开始，依次比较相邻的两个元素，将其中较大的元素交换到靠后的位置，当这轮比较结束，所有比较元素中的最大元素已移动到了最后边。**注意：每一轮都是从下标位置0开始，结束的下标位置依次为size-1, size-2, ..., 1**
   2. 优化：若在一轮比较中，没有发生任何交换，说明数据已经完全有序，无需继续比较下去
   3. 稳定性：是稳定排序
   4. 时间复杂度：O(n^2)

4. **向下冒泡排序**

   第i轮，将arr[i-1]与其后面位置的所有元素比较，若存在较小元素，交换到arr[i-1]位置。一轮结束之后，将比较元素中最小的元素放到了下标为i-1的位置。

   与上一个冒泡排序的区别：即使初始数据完全有序，也得比较i-1轮

5. **插入排序**

   1. 实现：将原始数据分为两个区间，**已排序区间**和**未排序区间**。初始状态，已排序区间只有一个元素，即下标为0的元素。每一轮比较时，从未排序区间取出第一个元素，将其插入到已排序区间的合适位置。
   2. 稳定性：是稳定排序
   3. 时间复杂度：O(n^2)
   4. 优化：参考**希尔排序**

6. **选择排序**

   1. 实现：将原始数据分为两个区间，**已排序区间**和**未排序区间**。初始状态，已排序区间没有元素，在每一轮的元素比较过程中，记录较小元素的下标，一轮比较结束后，将标记的最小元素与已排序区间的末尾后一个元素交换

   2. 稳定性：不是稳定排序

      在将标记的最小元素与已排序区间末尾的后面一个元素（暂定为**x元素**）交换时，可能已经打乱了“x元素”与其相等元素的顺序。故不是稳定排序。

   3. 时间复杂度：O(n^2)

7. 为什么大家一般愿意选择插入排序，而不选择冒泡排序

   插入排序与冒泡排序时间复杂度相同，且都是稳定性排序。对于同样的数据，其数据交换次数也是相同的，即都是“有序度”次数的交换。只是交换数据时有所区别。插入排序增加一个有序度只需要移动一行代码，而冒泡排序增加一个有序度需要执行4行代码。那么在数据比较大时，当然插入排序效率要高了

   ```java
   冒泡排序中数据的交换操作：
   if (a[j] > a[j+1]) { // 交换
      int tmp = a[j];
      a[j] = a[j+1];
      a[j+1] = tmp;
      flag = true;
   }
   
   插入排序中数据的移动操作：
   if (a[j] > value) {
     a[j+1] = a[j];  // 数据移动
   } else {
     break;
   }
   ```

8. 