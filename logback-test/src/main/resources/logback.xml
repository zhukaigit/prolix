<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property name="LOG_HOME" value="logs"/>
    <property name="encoding" value="UTF-8"/>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <target>System.out</target>
        <encoding>UTF-8</encoding>
        <filter class="com.zk.logback.LevelRangeFilter">
            <levelMin>INFO</levelMin>
            <levelMax>WARN</levelMax>
        </filter>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger %line - %m%n</pattern>
        </encoder>
    </appender>

    <appender name="STDERR" class="ch.qos.logback.core.ConsoleAppender">
        <target>System.err</target>
        <encoding>UTF-8</encoding>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger %line - %m%n</pattern>
        </encoder>
    </appender>

    <appender name="COMMON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 设置文件名，即当前写入的文件名称 -->
        <file>${LOG_HOME}/sizeAndTime.log</file>

        <!-- TimeBasedRollingPolicy和SizeBasedTriggeringPolicy冲突，所以想要用size和time控制，用下面这个策略 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/sizeAndTime.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!-- 定义每一个日志文件大小上限 -->
            <maxFileSize>1MB</maxFileSize>
            <!-- 每一个日志文件保留的天数 -->
            <!-- 如：若设置成2，则在2019.05.18生成的日志，最晚保存到2019.05.20这一天，21日就会删除 -->
            <maxHistory>2</maxHistory>
            <!-- 所有文件的尺寸上限 -->
            <!-- 当超过该尺寸后，会将最早的文件删除掉，保留最新的文件，保留文件的数量接近于该尺寸 -->
            <totalSizeCap>100MB</totalSizeCap>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [traceId] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 输出源：排除job日志，只记录log级别的日志  -->
    <appender name="FILE2" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 设置文件名，即当前写入的文件名称 -->
        <file>${LOG_HOME}/job.log</file>

        <!-- 排除job日志 -->
        <filter class="com.zk.logback.IsJobLogFilter">
            <!-- 匹配则排除 -->
            <OnMatch>DENY</OnMatch>
            <!-- 不匹配，交给下一个过滤器处理 -->
            <OnMismatch>NATURE</OnMismatch>
        </filter>
        <!-- 日志级别过滤器 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>

        <!-- TimeBasedRollingPolicy和SizeBasedTriggeringPolicy冲突，所以想要用size和time控制，用下面这个策略 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/job.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!-- 定义每一个日志文件大小上限 -->
            <maxFileSize>1MB</maxFileSize>
            <!-- 每一个日志文件保留的天数 -->
            <!-- 如：若设置成2，则在2019.05.18生成的日志，最晚保存到2019.05.20这一天，21日就会删除 -->
            <maxHistory>2</maxHistory>
            <!-- 所有文件的尺寸上限 -->
            <!-- 当超过该尺寸后，会将最早的文件删除掉，保留最新的文件，保留文件的数量接近于该尺寸 -->
            <totalSizeCap>100MB</totalSizeCap>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS}[%X{IS_JOB}] [%thread] [traceId] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- job 日志输出源 -->
    <appender name="JOB_LOG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 设置文件名，即当前写入的文件名称 -->
        <file>${LOG_HOME}/job.log</file>

        <!-- job 日志过滤器 -->
        <filter class="ch.qos.logback.core.filter.EvaluatorFilter">
            <evaluator>
                <!-- 条件为： mdc中设置IS_JOB为"THIS_IS_JOB", 即MDC.put("IS_JOB","THIS_IS_JOB")-->
                <expression>return mdc.get("IS_JOB") == "THIS_IS_JOB";</expression>
            </evaluator>
            <OnMatch>ACCEPT</OnMatch>
            <OnMismatch>DENY</OnMismatch>
        </filter>
        <!-- 或者使用自定义过滤器 -->
        <!--<filter class="com.zk.logback.IsJobLogFilter">-->
        <!--<OnMatch>ACCEPT</OnMatch>-->
        <!--<OnMismatch>DENY</OnMismatch>-->
        <!--</filter>-->

        <!-- TimeBasedRollingPolicy和SizeBasedTriggeringPolicy冲突，所以想要用size和time控制，用下面这个策略 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/job.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!-- 定义每一个日志文件大小上限 -->
            <maxFileSize>1MB</maxFileSize>
            <!-- 每一个日志文件保留的天数 -->
            <!-- 如：若设置成2，则在2019.05.18生成的日志，最晚保存到2019.05.20这一天，21日就会删除 -->
            <maxHistory>2</maxHistory>
            <!-- 所有文件的尺寸上限 -->
            <!-- 当超过该尺寸后，会将最早的文件删除掉，保留最新的文件，保留文件的数量接近于该尺寸 -->
            <totalSizeCap>100MB</totalSizeCap>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS}[%X{IS_JOB}] [%thread] [traceId] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>


    <logger name="com.test.demo" level="DEBUG">
        <appender-ref ref="FILE"/>
    </logger>

    <!-- 日志输出级别 -->
    <root level="INFO">
        <!--<appender-ref ref="COMMON_FILE"/>-->
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="STDERR"/>
        <!--<appender-ref ref="JOB_LOG"/>-->
    </root>
</configuration>